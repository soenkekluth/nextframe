{"version":3,"file":"nextframe.js","sources":["../node_modules/raf/index.js","../node_modules/performance-now/lib/performance-now.js","../src/nextframe.js"],"sourcesContent":["var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function() {\n  root.requestAnimationFrame = raf\n  root.cancelAnimationFrame = caf\n}\n","// Generated by CoffeeScript 1.12.2\n(function() {\n  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - nodeLoadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    moduleLoadTime = getNanoSeconds();\n    upTime = process.uptime() * 1e9;\n    nodeLoadTime = moduleLoadTime - upTime;\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n\n//# sourceMappingURL=performance-now.js.map\n","import raf from 'raf';\n\n/**\n * create a Promise that resolves in the next Animationframe\n * @param  {...} args - optional values that would be the params of the Promises resolve\n * @return {Promise} which will resolve in the next Animationframe\n */\nexport const nextFrame = (...args) => new Promise(resolve => raf(() => { resolve(...args); }));\n\n/**\n * waiting x frames before the Promise will resolve\n * @param  {Number}    frame - the number of frames the Promise waits before resolving\n * @param  {...} args \t- optional values that would be the params of the Promises resolve\n * @return {Promise} which will resolve after the waiting frames\n */\nexport const waitFrames = (frame = 1, ...args) => new Promise((resolve) => {\n  let i = 0;\n  const count = () => {\n    if (++i >= frame) {\n      return resolve(frame, ...args);\n    }\n    raf(count);\n  }\n  raf(count);\n});\n\n\n/**\n * resolve when fn returns a truthy value.\n * @param  {Function}  fn   a function that will be called every frame to check for changes\n * @param  {...[type]} args  \t- optional values that would be the params of the Promises resolve\n * @return {Promise} which will resolve after the waiting frames\n */\nexport const when = (fn, ...args) => {\n  return nextFrame()\n    .then(() => {\n      const result = fn(...args);\n      if (result) {\n        return (args && (args.length > 1)) ? args : result;\n      }\n      return when(fn, ...args);\n    });\n};\n\n\n/**\n * until fn returns a truthy value do not resolve.\n * @param  {Function}  fn   a function that will be called every frame to check for changes\n * @param  {...[type]} args  \t- optional values that would be the params of the Promises resolve\n * @return {Promise} which will resolve after the waiting frames\n */\nexport const until = (fn, ...args) => {\n  return nextFrame()\n    .then(() => {\n      const result = fn(...args);\n      if (result) {\n      \treturn until(fn, ...args);\n      }\n       return (args && (args.length > 1)) ? args : result;\n    });\n};\n\n\n/**\n * create an animationframe loop that calls a function (callback) in every frame\n * @param  {Function} cb - gets called in every frame - for rendering mostly\n * @return {Function}  a function which cancels the initialed loop by calling it\n */\nexport const loop = (cb) => {\n  if (typeof cb !== 'function') {\n    throw 'callback needs to be a function';\n  }\n  let f = true;\n  const frame = () => {\n    if (f) {\n      cb();\n      raf(frame);\n    }\n  }\n  raf(frame);\n  return () => {\n    f = false;\n  };\n};\n\n\n/**\n * create a throttled animationframe loop that calls a function (callback) in every specified\n * @param  {Function} cb        gets called in every specified frame\n * @param  {Number}   throttle in wich interval cb is called\n * @return {Function}  a function which cancels the initialed loop by calling it\n */\nexport const throttleFrames = (cb, throttle = 0) => {\n  if (typeof cb !== 'function') {\n    throw 'callback needs to be a function';\n  }\n  let f = true;\n  let i = 0;\n  const frame = () => {\n    ++i;\n    if (f) {\n      if (throttle && (i % throttle === 0)) {\n        cb();\n      }\n      raf(frame);\n    }\n  }\n  raf(frame);\n  return () => {\n    f = false;\n  };\n};\n\n/**\n * delays the call to nextFrame with setTimeout\n * @param  {Number}    ms    delay in ms\n * @param  {...} args \t- optional values that would be the params of the Promises resolve\n * @return {Promise} which will resolve after the delayed animationframe\n */\nexport const delay = (ms = 0, ...args) => new Promise((resolve, reject) => setTimeout(() => {\n  nextFrame()\n    .then(() => resolve(...args));\n}, ms));\n\n\n/**\n * call a function sequencely every next frame on every iterating position of an array\n * @param  {Array}   collection keeps all values that will be used as the argument for the function\n * @param  {Function} fn         will be called with array values as aruments\n * @return {Promise} which will resolve after the sequence\n */\nexport const sequence = (collection, fn) => {\n  let chain = Promise.resolve();\n  const values = [];\n  collection.forEach(item => {\n    chain = chain\n      .then(() => nextFrame().then(() => values.push(fn(item))));\n  });\n  return chain.then(() => values);\n}\n\n\nexport { sequence as frameSequence }\nexport { waitFrames as wait }\nexport { loop as nextFrames }\nexport { loop as onEnterFrame }\nexport { throttleFrames as throttle }\nexport { nextFrame as frame }\nexport default nextFrame;\n"],"names":["getNanoSeconds","hrtime","loadTime","moduleLoadTime","nodeLoadTime","upTime","performance","now","module","process","hr","uptime","Date","getTime","call","this","root","window","global","vendors","suffix","raf","caf","i","length","last","id","queue","callback","_now","next","Math","max","setTimeout","cp","slice","cancelled","e","round","push","handle","fn","apply","arguments","requestAnimationFrame","cancelAnimationFrame","nextFrame","args","Promise","waitFrames","frame","resolve","count","loop","cb","f","throttleFrames","throttle","sequence","collection","chain","values","forEach","then","item","when","result","until","ms","reject"],"mappings":"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"}